) %>%
# 只保留有数据的连续段
filter(has_data) %>%
ungroup() %>%
complete(year, clone, fill = list(prevalence = 0)) %>%
mutate(
year = factor(year, levels = unique(year)),
clone = factor(clone, levels = clone_order)
)
# 重新计算比例
df_clean <- df_clean %>%
group_by(year) %>%
mutate(
total = sum(prevalence, na.rm = TRUE),
prevalence_prop = ifelse(total > 0, prevalence / total, 0)
) %>%
ungroup()
p3 <- ggplot(df_clean, aes(x = year, y = prevalence_prop, fill = clone)) +
geom_stream(
type = "proportional",
bw = 0.7,
extra_span = 0.2,
color = "white",
linewidth = 0.15
) +
scale_fill_manual(values = clone_cols) +
scale_y_continuous(labels = percent) +
labs(
x = "Year",
y = "Relative prevalence",
title = "Temporal dynamics of ST410 subclones"
) +
theme_classic(base_size = 14) +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = "black"),
legend.position = "none",
axis.line.y = element_blank(),
axis.ticks.y = element_blank()
) +
geom_text_repel(
data = label_df,
aes(label = clone),
nudge_x = 0.5,
direction = "y",
size = 4,
segment.color = NA
)
print(p3)
# =====================================================
# 保存结果
# =====================================================
ggsave("ST410_stream_ridge.pdf", p1, width = 11, height = 7, dpi = 300, bg = "white")
ggsave("ST410_stream_proportional.pdf", p2, width = 11, height = 7, dpi = 300, bg = "white")
ggsave("ST410_stream_clean.pdf", p3, width = 11, height = 7, dpi = 300, bg = "white")
# =====================================================
# 输出调试信息
# =====================================================
cat("\n数据完整性检查:\n")
for(cl in clone_order) {
cl_data <- df %>% filter(clone == cl)
nonzero_years <- cl_data %>% filter(prevalence > 0) %>% pull(year)
cat(sprintf("%-15s: 首次出现在 %s, 数据年份: %s\n",
cl,
min(nonzero_years),
paste(nonzero_years, collapse = ", ")))
}
#install.packages("devtools")
#devtools::install_github("davidsjoberg/ggstream")
setwd("/Users/hewanyun/Downloads/stream")
# library
library(ggplot2)
library(ggstream)
library(dplyr)
library(ggrepel)
library(readr)
library(scales)
# 读取数据
df <- read_csv("ST410_subclones.csv")
# =====================================================
# 关键修复：确保每个克隆只在实际出现的年份显示
# =====================================================
# 1. 首先固定克隆顺序
clone_order <- c("A/H53", "B1/H24", "B2/H24R", "B3/H24Rx_1", "B3/H24Rx_2", "B3/H24Rx_3", "B4/H24RxC", "B5/H24RxC")
# 2. 找出每个克隆首次出现的年份
clone_first_years <- df %>%
filter(prevalence > 0) %>%
group_by(clone) %>%
summarise(
first_year = min(year),
.groups = "drop"
)
cat("每个克隆首次出现的年份:\n")
print(clone_first_years)
# 3. 关键步骤：对于每个克隆，在首次出现之前将值设为极小值（接近0但不是0）
# 这样流图会认为该克隆存在但比例极小，不会插值显示
df_processed <- df %>%
left_join(clone_first_years, by = "clone") %>%
mutate(
year = factor(year, levels = unique(year)),
clone = factor(clone, levels = clone_order),
# 在首次出现之前，设为极小值（1e-6，即0.0001%）
prevalence_adj = ifelse(
year < first_year,
1e-6,  # 极小值，几乎看不见但保证流图连续性
prevalence
)
) %>%
select(-first_year)
# 4. 重新计算比例（考虑极小值）
df_final <- df_processed %>%
group_by(year) %>%
mutate(
total = sum(prevalence_adj),
prevalence_prop = prevalence_adj / total
) %>%
ungroup()
# 检查处理后的数据
cat("\n处理后的数据示例（查看极小值处理）:\n")
for(cl in clone_order) {
cat(paste0("\n", cl, ":\n"))
print(df_final %>%
filter(clone == cl) %>%
select(year, prevalence, prevalence_adj, prevalence_prop) %>%
head(3))
}
# =====================================================
# 关键修复2：使用ridge类型并调整参数
# =====================================================
# 使用ridge类型可以更好地控制显示的阈值
df_ridge <- df_final %>%
mutate(
# 对于ridge类型，将首次出现之前的值设为0
prevalence_ridge = ifelse(
prevalence_adj == 1e-6,
0,  # 对于ridge类型，直接设为0
prevalence
)
)
# =====================================================
# label_df - 只标注实际有数据的点（prevalence > 0.001）
# =====================================================
label_df <- df_final %>%
filter(prevalence > 0.001) %>%
group_by(clone) %>%
slice_tail(n = 1) %>%
ungroup()
# =====================================================
# ISME / Nature 风格配色
# =====================================================
clone_cols <- c(
"A/H53"      = "#9B7FCB",
"B1/H24"     = "#95765C",
"B2/H24R"    = "#B2BC8A",
"B3/H24Rx_1" = "#ffe699",
"B3/H24Rx_2" = "#fecc66",
"B3/H24Rx_3" = "#fd8008",
"B4/H24RxC"  = "#76D5FF",
"B5/H24RxC"  = "#FF7E79"
)
# =====================================================
# 方法1：使用ridge类型（推荐）
# =====================================================
p1 <- ggplot(df_ridge, aes(x = year, y = prevalence_ridge, fill = clone)) +
geom_stream(
type = "ridge",  # 使用ridge而不是proportional
bw = 0.7,
extra_span = 0.1,
color = "white",
linewidth = 0.15,
sorting = "onset",
true_range = "none"  # 不自动扩展范围
) +
scale_fill_manual(values = clone_cols) +
scale_y_continuous(
labels = percent,
limits = c(0, NA),  # 从0开始
expand = expansion(mult = c(0, 0.05))
) +
labs(
x = "Year",
y = "Prevalence",
title = "Temporal dynamics of ST410 subclones",
subtitle = "Each clone appears only when actually present (>0%)"
) +
theme_classic(base_size = 14) +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = "black"),
legend.position = "none",
axis.line.y = element_blank(),
axis.ticks.y = element_blank(),
plot.title = element_text(hjust = 0.5, face = "bold"),
plot.subtitle = element_text(hjust = 0.5, color = "gray50", size = 11)
) +
geom_text_repel(
data = label_df,
aes(label = clone),
nudge_x = 0.5,
direction = "y",
size = 4,
segment.color = NA,
min.segment.length = 0
)
print(p1)
# =====================================================
# 方法2：使用proportional类型但设置显示阈值
# =====================================================
# 对于比例图，我们需要确保0值不会干扰
p2 <- ggplot(df_final, aes(x = year, y = prevalence_prop, fill = clone)) +
geom_stream(
type = "proportional",
bw = 0.65,
extra_span = 0.15,
color = "white",
linewidth = 0.15,
sorting = "onset"
) +
scale_fill_manual(values = clone_cols) +
scale_y_continuous(
labels = percent,
limits = c(0, 1),
expand = c(0, 0)
) +
labs(
x = "Year",
y = "Relative prevalence",
title = "Temporal dynamics of ST410 subclones"
) +
theme_classic(base_size = 14) +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = "black"),
legend.position = "none",
axis.line.y = element_blank(),
axis.ticks.y = element_blank()
) +
geom_text_repel(
data = label_df,
aes(label = clone),
nudge_x = 0.5,
direction = "y",
size = 4,
segment.color = NA
) +
# 添加透明度渐变效果，使极小值几乎看不见
scale_alpha_continuous(range = c(0.1, 1), guide = "none")
print(p2)
# =====================================================
# 方法3：最直接的方法 - 过滤数据并重新堆叠
# =====================================================
# 为每个克隆创建连续的数据，但在首次出现之前设为NA
df_clean <- df %>%
# 找出每个克隆的有效数据范围
group_by(clone) %>%
mutate(
has_data = prevalence > 0,
# 标记连续的数据段
data_group = cumsum(has_data != lag(has_data, default = first(has_data)))
) %>%
# 只保留有数据的连续段
filter(has_data) %>%
ungroup() %>%
complete(year, clone, fill = list(prevalence = 0)) %>%
mutate(
year = factor(year, levels = unique(year)),
clone = factor(clone, levels = clone_order)
)
# 重新计算比例
df_clean <- df_clean %>%
group_by(year) %>%
mutate(
total = sum(prevalence, na.rm = TRUE),
prevalence_prop = ifelse(total > 0, prevalence / total, 0)
) %>%
ungroup()
p3 <- ggplot(df_clean, aes(x = year, y = prevalence_prop, fill = clone)) +
geom_stream(
type = "proportional",
bw = 0.7,
extra_span = 0.2,
color = "white",
linewidth = 0.15
) +
scale_fill_manual(values = clone_cols) +
scale_y_continuous(labels = percent) +
labs(
x = "Year",
y = "Relative prevalence",
title = "Temporal dynamics of ST410 subclones"
) +
theme_classic(base_size = 14) +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = "black"),
legend.position = "none",
axis.line.y = element_blank(),
axis.ticks.y = element_blank()
) +
geom_text_repel(
data = label_df,
aes(label = clone),
nudge_x = 0.5,
direction = "y",
size = 4,
segment.color = NA
)
print(p3)
# =====================================================
# 保存结果
# =====================================================
ggsave("ST410_stream_ridge.pdf", p1, width = 11, height = 7, dpi = 300, bg = "white")
ggsave("ST410_stream_proportional.pdf", p2, width = 11, height = 7, dpi = 300, bg = "white")
ggsave("ST410_stream_clean.pdf", p3, width = 11, height = 7, dpi = 300, bg = "white")
# =====================================================
# 输出调试信息
# =====================================================
cat("\n数据完整性检查:\n")
for(cl in clone_order) {
cl_data <- df %>% filter(clone == cl)
nonzero_years <- cl_data %>% filter(prevalence > 0) %>% pull(year)
cat(sprintf("%-15s: 首次出现在 %s, 数据年份: %s\n",
cl,
min(nonzero_years),
paste(nonzero_years, collapse = ", ")))
}
setwd("/Users/hewanyun/Downloads/heatmap")
# ==================== 1. 加载包 ====================
required_packages <- c("tidyverse", "ggplot2", "viridis", "RColorBrewer", "scales")
new_packages <- required_packages[!required_packages %in% installed.packages()[,"Package"]]
if(length(new_packages)) install.packages(new_packages)
library(tidyverse)
library(ggplot2)
library(viridis)
library(RColorBrewer)
library(scales)
# ==================== 2. 数据准备 ====================
data <- read.csv("Heatmap_data.csv", stringsAsFactors = FALSE)
# 数据处理 - 保留Total
heatmap_data <- data %>%
mutate(
# 注意：你的Percentage列已经是百分比（0-100），不需要转换
Percent = Percentage,  # 直接使用原值
# 定义基因型顺序（Total在最前面）
Type = factor(Type,
levels = c("Total", "A/H53", "B1/H24", "B2/H24R",
"B3/H24Rx", "B4/H24RxC", "B5/H24RxC")),
# 定义宿主顺序（按Total比例从高到低排序）
Source = factor(Source)
)
# 为了按Total比例排序宿主，先计算Total行
total_order <- heatmap_data %>%
filter(Type == "Total") %>%
arrange(desc(Percent)) %>%
pull(Source)
# 重新排序宿主因子
heatmap_data$Source <- factor(heatmap_data$Source, levels = total_order)
# 查看数据范围
cat("数据维度:", dim(heatmap_data), "\n")
cat("基因型:", levels(heatmap_data$Type), "\n")
cat("宿主数量:", length(levels(heatmap_data$Source)), "\n")
cat("百分比范围:", sprintf("%.2f%% 到 %.2f%%",
min(heatmap_data$Percent, na.rm = TRUE),
max(heatmap_data$Percent, na.rm = TRUE)), "\n\n")
# ==================== 3. 创建圆形热力图（颜色代表数值，点大小统一） ====================
p1 <- ggplot(heatmap_data, aes(x = Type, y = Source)) +
# 使用圆形，点大小统一，颜色编码百分比
geom_point(aes(color = Percent),
size = 9.5,  # 统一大小
shape = 19,
alpha = 0.85,
stroke = 0) +
# 只在圆形内部添加数值标签
geom_text(aes(label = ifelse(Percent >= 1,
sprintf("%.1f", Percent),
ifelse(Percent >= 0.1,
sprintf("%.1f", Percent),
ifelse(Percent > 0, "<0.1", "0.0")))),
color = "black",
size = 3.5) +
# 颜色渐变（viridis magma调色板）
scale_color_viridis(
option = "magma",
name = "(%)",
limits = c(0, 100),
direction = -1,  # 反向：高值亮色，低值暗色
begin = 0.1,     # 调整起始颜色
end = 0.95,      # 调整结束颜色
na.value = "black"
) +
# 主题设置
theme_minimal(base_size = 12) +
theme(
# 坐标轴文本
axis.text.x = element_text(face = "bold", angle = 90, hjust = 1, vjust = 0.5, size = 11, color = "black"),
axis.text.y = element_text(face = "bold", size = 11, color = "black"),
# 移除坐标轴标题
axis.title = element_blank(),
# 网格线
panel.grid.major = element_line(color = "gray93", size = 0.3),
panel.grid.minor = element_blank(),
# 图例
legend.position = "right",
legend.key.height = unit(1.8, "cm"),
legend.key.width = unit(0.5, "cm"),
legend.title = element_text(size = 11, vjust = 0.8),
legend.text = element_text(size = 10, color = "black"),
# 标题
plot.title = element_text(face = "bold", size = 16, hjust = 0.5,
margin = margin(b = 15)),
plot.subtitle = element_text(size = 12, hjust = 0.5, color = "black",
margin = margin(b = 10)),
# 边距
plot.margin = margin(20, 20, 20, 20)
) +
# 标签
labs(
title = "Ecological distribution"
)
print(p1)
ggsave("heatmap_dots.pdf", p1, width = 9, height = 12, dpi = 300, bg = "white")
setwd("/Users/hewanyun/Downloads/heatmap")
# ==================== 1. 加载包 ====================
required_packages <- c("tidyverse", "ggplot2", "viridis", "RColorBrewer", "scales")
new_packages <- required_packages[!required_packages %in% installed.packages()[,"Package"]]
if(length(new_packages)) install.packages(new_packages)
library(tidyverse)
library(ggplot2)
library(viridis)
library(RColorBrewer)
library(scales)
# ==================== 2. 数据准备 ====================
data <- read.csv("Heatmap_data.csv", stringsAsFactors = FALSE)
# 数据处理 - 保留Total
heatmap_data <- data %>%
mutate(
# 注意：你的Percentage列已经是百分比（0-100），不需要转换
Percent = Percentage,  # 直接使用原值
# 定义基因型顺序（Total在最前面）
Type = factor(Type,
levels = c("Total", "A/H53", "B1/H24", "B2/H24R",
"B3/H24Rx", "B4/H24RxC", "B5/H24RxC")),
# 定义宿主顺序（按Total比例从高到低排序）
Source = factor(Source)
)
# 为了按Total比例排序宿主，先计算Total行
total_order <- heatmap_data %>%
filter(Type == "Total") %>%
arrange(desc(Percent)) %>%
pull(Source)
# 重新排序宿主因子
heatmap_data$Source <- factor(heatmap_data$Source, levels = total_order)
# 查看数据范围
cat("数据维度:", dim(heatmap_data), "\n")
cat("基因型:", levels(heatmap_data$Type), "\n")
cat("宿主数量:", length(levels(heatmap_data$Source)), "\n")
cat("百分比范围:", sprintf("%.2f%% 到 %.2f%%",
min(heatmap_data$Percent, na.rm = TRUE),
max(heatmap_data$Percent, na.rm = TRUE)), "\n\n")
# ==================== 3. 创建圆形热力图（颜色代表数值，点大小统一） ====================
p1 <- ggplot(heatmap_data, aes(x = Type, y = Source)) +
# 使用圆形，点大小统一，颜色编码百分比
geom_point(aes(color = Percent),
size = 9.5,  # 统一大小
shape = 19,
alpha = 0.85,
stroke = 0) +
# 只在圆形内部添加数值标签
geom_text(aes(label = ifelse(Percent >= 1,
sprintf("%.1f", Percent),
ifelse(Percent >= 0.1,
sprintf("%.1f", Percent),
ifelse(Percent > 0, "<0.1", "0.0")))),
color = "black",
size = 3.5) +
# 颜色渐变（viridis magma调色板）
scale_color_viridis(
option = "magma",
name = "(%)",
limits = c(0, 100),
direction = -1,  # 反向：高值亮色，低值暗色
begin = 0.1,     # 调整起始颜色
end = 0.95,      # 调整结束颜色
na.value = "black"
) +
# 主题设置
theme_minimal(base_size = 12) +
theme(
# 坐标轴文本
axis.text.x = element_text(face = "bold", angle = 90, hjust = 1, vjust = 0.5, size = 11, color = "black"),
axis.text.y = element_text(face = "bold", size = 11, color = "black"),
# 移除坐标轴标题
axis.title = element_blank(),
# 网格线
panel.grid.major = element_line(color = "gray93", size = 0.3),
panel.grid.minor = element_blank(),
# 图例
legend.position = "right",
legend.key.height = unit(1.8, "cm"),
legend.key.width = unit(0.5, "cm"),
legend.title = element_text(size = 11, vjust = 0.8),
legend.text = element_text(size = 10, color = "black"),
# 标题
plot.title = element_text(face = "bold", size = 16, hjust = 0.5,
margin = margin(b = 15)),
plot.subtitle = element_text(size = 12, hjust = 0.5, color = "black",
margin = margin(b = 10)),
# 边距
plot.margin = margin(20, 20, 20, 20)
) +
# 标签
labs(
title = "Ecological distribution"
)
print(p1)
ggsave("heatmap_dots.pdf", p1, width = 9, height = 12, dpi = 300, bg = "white")
