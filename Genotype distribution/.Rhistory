# Remove rows with missing abundance values
filter(!is.na(Relative_abundance))
# Inspect cleaned data
cat("Data cleaning completed.\n")
cat(paste("Number of rows:", nrow(data_clean), "\n"))
cat(paste("Number of types:", length(unique(data_clean$Type)), "\n"))
cat("Preview of cleaned data:\n")
print(head(data_clean, 10))
# Preserve the original order of Type as it appears in the data
type_order <- unique(data_clean$Type)
data_clean <- data_clean %>%
mutate(Type = factor(Type, levels = type_order))
# =========================================================
# 3. Normalize abundance values (0–1 scaling)
# =========================================================
# Normalize relative abundance within each type
data_norm <- data_clean %>%
group_by(Type) %>%
mutate(
# Normalization formula: (x - min) / (max - min)
Abundance_norm = (Relative_abundance - min(Relative_abundance)) /
(max(Relative_abundance) - min(Relative_abundance))
) %>%
ungroup()
# Verify normalization results
cat("\nChecking normalization results:\n")
for (tp in unique(data_norm$Type)) {
subset_data <- data_norm[data_norm$Type == tp, ]
cat(
paste(
tp, ": original range [",
round(min(subset_data$Relative_abundance), 3), ", ",
round(max(subset_data$Relative_abundance), 3),
"], normalized range [",
round(min(subset_data$Abundance_norm), 3), ", ",
round(max(subset_data$Abundance_norm), 3), "]\n",
sep = ""
)
)
}
# =========================================================
# 4. Calculate statistical metrics
# =========================================================
stats <- data_norm %>%
group_by(Type) %>%
summarise(
# Basic statistics
n_points = n(),
mean_abundance = mean(Relative_abundance),
# Linear regression on normalized abundance
slope = lm(Abundance_norm ~ Year)$coefficients[2],
p_value = summary(lm(Abundance_norm ~ Year))$coefficients[2, 4],
R2 = summary(lm(Abundance_norm ~ Year))$r.squared,
# Pearson correlation
r = cor(Abundance_norm, Year, method = "pearson"),
# Label positioning for plots
label_x = median(Year),
label_y = max(Abundance_norm) * 0.85,
.groups = "drop"
) %>%
# Format statistical labels
mutate(
p_label = case_when(
p_value < 0.001 ~ "p < 0.001",
p_value < 0.01 ~ "p < 0.01",
p_value < 0.05 ~ sprintf("p < %.3f", p_value),
TRUE ~ sprintf("p = %.3f", p_value)
),
R2_label = sprintf("R² = %.3f", R2),
r_label = sprintf("r = %.3f", r),
stat_label = paste(p_label, R2_label, r_label, sep = "\n")
)
# Display statistical summary
print(stats[, c("Type", "n_points", "p_label", "R2_label", "r_label")])
# =========================================================
# 5. Visualization
# =========================================================
p <- ggplot(data_norm, aes(x = Year, y = Abundance_norm)) +
# Scatter points
geom_point(color = "#377EB8", size = 3, alpha = 0.7) +
# Linear regression line with confidence interval
geom_smooth(
method = "lm",
formula = y ~ x,
color = "#E41A1C",
fill = "#FF9999",
alpha = 0.3,
linewidth = 1.0,
se = TRUE
) +
# Facet by type
facet_wrap(~ Type, ncol = 3, scales = "free_y") +
# Add statistical annotations
geom_text(
data = stats,
aes(x = label_x, y = label_y, label = stat_label),
size = 3.5,
hjust = 1,
vjust = 0.5,
color = "black"
) +
# Theme customization
theme_bw(base_size = 12) +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(color = "gray90", linewidth = 0.3),
panel.border = element_rect(color = "black", linewidth = 0.5),
strip.background = element_rect(fill = "gray95", color = "gray50"),
strip.text = element_text(face = "bold", size = 11),
axis.text = element_text(color = "black"),
axis.title = element_text(face = "bold"),
plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
plot.subtitle = element_text(hjust = 0.5, size = 11)
) +
# Labels
labs(
x = "Year",
y = "Relative abundance (normalized)",
title = "Temporal trends",
subtitle = "Linear regression with Pearson correlation"
) +
# Axis settings
scale_x_continuous(
breaks = seq(2012, 2024, by = 4),
limits = c(2011.5, 2024.5)
) +
ylim(0, 1)
# Display plot
print(p)
# =========================================================
# 6. Save results
# =========================================================
# Save statistical results
write.csv(stats, "Statistical_results.csv", row.names = FALSE)
# Save cleaned and normalized data
write.csv(data_norm, "Cleaned_normalized_data.csv", row.names = FALSE)
setwd("/Users/hewanyun/Desktop/ISME/2. ISME J/ISME Data/Code availability/Temporal dynamics")
# Stream Plot for ST410 Subclones
#
# Purpose: Generate a temporal stream plot showing relative prevalence of ST410 subclones over years using ggstream.
#
# Dependencies:
#   - ggplot2
#   - ggstream
#   - dplyr
#   - ggrepel
#   - readr
#   - scales
#
# Input:
#   - "ST410_subclones.csv": CSV file containing columns:
#       Year       (numeric or factor)
#       Clone      (subclone identifier)
#       Prevalence (numeric, relative abundance)
#
# Load libraries
library(ggplot2)
library(ggstream)
library(dplyr)
library(ggrepel)
library(readr)
library(scales)
# Load subclone data
df <- read_csv("ST410_subclones.csv")
# =====================================================
# 1. Prepare sorting variable to ensure correct stacking
# =====================================================
# Define fixed clone order (can be customized)
clone_order <- c("A/H53", "B1/H24", "B2/H24R", "B3/H24Rx_1",
"B3/H24Rx_2", "B4/H24RxC", "B5/H24RxC")
# Assign numeric sort value to each clone
clone_sort_values <- setNames(1:length(clone_order), clone_order)
# Prepare dataframe with fixed ordering
df_prepared <- df %>%
mutate(
Year = factor(Year, levels = unique(Year)),      # Keep year order
Clone = factor(Clone, levels = clone_order),    # Set clone factor order
sort_value = clone_sort_values[as.character(Clone)]  # Sorting variable
) %>%
arrange(Year, sort_value)  # Arrange by year and clone order
# =====================================================
# 2. Calculate cumulative prevalence for stacking
# =====================================================
df_final <- df_prepared %>%
group_by(Year) %>%
arrange(sort_value) %>%
mutate(
cumsum_prevalence = cumsum(Prevalence),  # cumulative sum per year
y_start = lag(cumsum_prevalence, default = 0)  # start point for each stream
) %>%
ungroup()
# =====================================================
# 3. Prepare labels for the last occurrence of each clone
# =====================================================
label_df <- df_final %>%
group_by(Clone) %>%
slice_tail(n = 1)  # take last year for labeling
# =====================================================
# 4. Define color palette
# =====================================================
clone_cols <- c(
"A/H53"      = "#9B7FCB",
"B1/H24"     = "#95765C",
"B2/H24R"    = "#B2BC8A",
"B3/H24Rx_1" = "#ffe699",
"B3/H24Rx_2" = "#fecc66",
"B4/H24RxC"  = "#76D5FF",
"B5/H24RxC"  = "#FF7E79"
)
# =====================================================
# 5. Generate the stream plot
# =====================================================
try({
p <- ggplot(df_final, aes(x = Year, y = Prevalence, fill = Clone)) +
geom_stream(
type = "proportional",   # proportional stacking
bw = 0.65,               # smoothness parameter
extra_span = 0.15,       # additional smoothing
color = "white",          # border color for streams
linewidth = 0.15,         # stream border width
sorting = "onset"         # sorting by first appearance
) +
scale_fill_manual(values = clone_cols) +
scale_y_continuous(labels = percent) +
labs(
x = "Year",
y = "Relative prevalence",
title = "Temporal dynamics of ST410 subclones"
) +
theme_classic(base_size = 14) +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = "black"),
legend.position = "none",
axis.line.y = element_blank(),
axis.ticks.y = element_blank()
) +
geom_text_repel(
data = label_df,
aes(label = Clone),
nudge_x = 0.5,
direction = "y",
size = 4,
segment.color = NA
)
print(p)
})
setwd("/Users/hewanyun/Desktop/ISME/2. ISME J/ISME Data/Code availability/Ecological distribution")
# Dot Heatmap of Ecological Distribution
#
# Purpose: Generate a dot-based heatmap to visualize the ecological distribution of different genotypes across host sources. Circle color represents percentage values, while circle size is kept constant for clarity.
#
# Dependencies:
#   - tidyverse
#   - ggplot2
#   - viridis
#   - RColorBrewer
#   - scales
#
# Input:
#   - "Heatmap_data.csv" with columns:
#       Type        (genotype / clone category)
#       Source      (host or ecological source)
#       Percentage  (percentage value, 0–100)
#
# =========================================================
# 1. Load required packages
# =========================================================
required_packages <- c("tidyverse", "ggplot2", "viridis", "RColorBrewer", "scales")
new_packages <- required_packages[
!required_packages %in% installed.packages()[, "Package"]
]
if (length(new_packages)) {
install.packages(new_packages)
}
library(tidyverse)
library(ggplot2)
library(viridis)
library(RColorBrewer)
library(scales)
# =========================================================
# 2. Data preparation
# =========================================================
# Read input data
data <- read.csv("Heatmap_data.csv", stringsAsFactors = FALSE)
# Process data (retain Total category)
heatmap_data <- data %>%
mutate(
# Percentage column is already scaled from 0 to 100
Percent = Percentage,
# Define genotype order (Total placed first)
Type = factor(
Type,
levels = c(
"Total", "A/H53", "B1/H24", "B2/H24R",
"B3/H24Rx", "B4/H24RxC", "B5/H24RxC",
"B3/H24Rx_1", "B3/H24Rx_2"
)
),
# Convert source to factor (ordering defined below)
Source = factor(Source)
)
# =========================================================
# 3. Reorder sources based on Total percentage
# =========================================================
# Determine source order by descending Total percentage
total_order <- heatmap_data %>%
filter(Type == "Total") %>%
arrange(desc(Percent)) %>%
pull(Source)
# Apply source ordering
heatmap_data$Source <- factor(heatmap_data$Source, levels = total_order)
# Inspect data range and structure
cat("Data dimensions:", dim(heatmap_data), "\n")
cat("Genotype levels:", levels(heatmap_data$Type), "\n")
cat("Number of sources:", length(levels(heatmap_data$Source)), "\n")
cat(
"Percentage range:",
sprintf(
"%.2f%% to %.2f%%",
min(heatmap_data$Percent, na.rm = TRUE),
max(heatmap_data$Percent, na.rm = TRUE)
),
"\n\n"
)
# =========================================================
# 4. Create dot heatmap
# =========================================================
p1 <- ggplot(heatmap_data, aes(x = Type, y = Source)) +
# Draw circles with uniform size; color encodes percentage
geom_point(
aes(color = Percent),
size = 9.5,
shape = 19,
alpha = 0.85,
stroke = 0
) +
# Add numeric labels inside circles
geom_text(
aes(
label = ifelse(
Percent >= 1,
sprintf("%.1f", Percent),
ifelse(
Percent >= 0.1,
sprintf("%.1f", Percent),
ifelse(Percent > 0, "<0.1", "0.0")
)
)
),
color = "black",
size = 3.5
) +
# Color scale using viridis (magma palette)
scale_color_viridis(
option = "magma",
name = "(%)",
limits = c(0, 100),
direction = -1,   # High values brighter, low values darker
begin = 0.1,
end = 0.95,
na.value = "black"
) +
# Theme and layout
theme_minimal(base_size = 12) +
theme(
axis.text.x = element_text(
face = "bold",
angle = 90,
hjust = 1,
vjust = 0.5,
size = 11,
color = "black"
),
axis.text.y = element_text(
face = "bold",
size = 11,
color = "black"
),
axis.title = element_blank(),
panel.grid.major = element_line(color = "gray93", linewidth = 0.3),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key.height = unit(1.8, "cm"),
legend.key.width = unit(0.5, "cm"),
legend.title = element_text(size = 11, vjust = 0.8),
legend.text = element_text(size = 10, color = "black"),
plot.title = element_text(
face = "bold",
size = 16,
hjust = 0.5,
margin = margin(b = 15)
),
plot.subtitle = element_text(
size = 12,
hjust = 0.5,
color = "black",
margin = margin(b = 10)
),
plot.margin = margin(20, 20, 20, 20)
) +
# Labels
labs(
title = "Ecological distribution"
)
# Display plot
print(p1)
setwd("/Users/hewanyun/Desktop/ISME/2. ISME J/ISME Data/Code availability/Distribution of genetic characteristics")
# Bubble Heatmap of Relative Abundance
#
# Dependencies:
#   - ggplot2
#   - dplyr
#
# Input:
#   - "Temporal_data.csv" with columns:
#       Type                (genotype)
#       Year                (time point)
#       Relative_abundance  (numeric, > 0)
#
##########################################################################
library(ggplot2)
library(dplyr)
# =========================================================
# 1. Read data
# =========================================================
# Disable automatic conversion of strings to factors
df <- read.csv("Temporal_data.csv", stringsAsFactors = FALSE)
# Remove zero-abundance entries
df2 <- df %>%
filter(Relative_abundance > 0)
# Preserve original ordering of Type and Year
df2$Type <- factor(df2$Type, levels = unique(df2$Type))
df2$Year <- factor(df2$Year, levels = unique(df$Year))
# =========================================================
# 2. Create background bands for row separation
# =========================================================
# Generate alternating background rectangles for each Type
bg <- data.frame(
Type = levels(df2$Type),
y_min = seq_along(levels(df2$Type)) - 0.5,
y_max = seq_along(levels(df2$Type)) + 0.5
)
# Assign background color to every second row
bg <- bg %>%
mutate(fill_color = ifelse(row_number() %% 2 == 0, "grey95", NA))
# =========================================================
# 3. Build bubble heatmap
# =========================================================
ggplot() +
# Alternating background stripes
geom_rect(
data = bg %>% filter(!is.na(fill_color)),
aes(xmin = -Inf, xmax = Inf, ymin = y_min, ymax = y_max),
fill = "grey95",
inherit.aes = FALSE
) +
# Bubble points encoding relative abundance
geom_point(
data = df2,
aes(
x = Year,
y = Type,
size = Relative_abundance,
fill = Relative_abundance   # ★ key: color encodes abundance
),
shape = 21,
color = "black",
alpha = 0.85
) +
# Size scale for abundance
scale_size_continuous(
limits = c(0, max(df2$Relative_abundance)),
breaks = seq(0.1, max(df2$Relative_abundance), by = 0.2),
range  = c(1.5, 10)
) +
# Fill color gradient (red scale)
# Alternative blue scale is provided in comments
scale_fill_gradient(
low  = "#FFF5F5",   # light red (low values)
high = "#C53030",   # dark red (high values)
name = "Relative abundance"
) +
# Place x-axis at the top
scale_x_discrete(position = "top") +
# Theme customization
theme_bw(base_size = 12) +
theme(
panel.grid = element_blank(),
panel.border = element_rect(color = "black", fill = NA),
axis.text.x = element_text(
face = "bold",
angle = 90,
hjust = 0,
vjust = 0.5,
size = 10,
color = "black"
),
axis.text.y = element_text(
face = "bold",
size = 10,
color = "black"
),
axis.title = element_text(size = 12, color = "black"),
legend.title = element_text(size = 11, color = "black"),
legend.text = element_text(color = "black")
) +
# Labels
labs(
x = "Year",
y = NULL,
size = "Relative abundance"
)
